generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                String              @id @default(cuid())
  walletAddress     String              @unique
  username          String?
  displayName       String?
  profileImage      String?
  walletBalance     Decimal             @default(0) @db.Decimal(18, 8)
  autoWithdrawEnabled Boolean           @default(false)
  autoWithdrawThreshold Decimal         @default(50) @db.Decimal(18, 8)
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  earnings          CreatorEarning[]
  videos            Video[]             @relation("UserVideos")
  viewSessions      ViewSession[]
  walletTransactions WalletTransaction[]
  settlements       Settlement[]
  likes             VideoLike[]
  subscriptions     Subscription[]      @relation("UserSubscriptions")
  subscribers       Subscription[]      @relation("CreatorSubscribers")

  @@map("users")
}

model Video {
  id             String        @id @default(cuid())
  title          String
  description    String?
  videoUrl       String
  thumbnailUrl   String
  duration       Int
  pricePerSecond Decimal       @db.Decimal(18, 8)
  totalEarnings  Decimal       @default(0) @db.Decimal(18, 8)
  category       String?
  tags           String[]
  totalViews     Int           @default(0)
  totalWatchTime Int           @default(0)
  totalLikes     Int           @default(0)
  creatorWallet  String
  publishedAt    DateTime      @default(now())
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  creator        User          @relation("UserVideos", fields: [creatorWallet], references: [walletAddress], onDelete: Cascade)
  viewSessions   ViewSession[]
  likes          VideoLike[]

  @@map("videos")
}

model ViewSession {
  id             String    @id @default(cuid())
  sessionToken   String    @unique
  startTime      DateTime  @default(now())
  endTime        DateTime?
  watchedSeconds Int       @default(0)
  amountCharged  Decimal   @default(0) @db.Decimal(18, 8)
  status         String    @default("ACTIVE")
  viewerId       String
  videoId        String
  video          Video     @relation(fields: [videoId], references: [id], onDelete: Cascade)
  viewer         User      @relation(fields: [viewerId], references: [id], onDelete: Cascade)

  @@map("view_sessions")
}

model CreatorEarning {
  id        String    @id @default(cuid())
  amount    Decimal   @db.Decimal(18, 8)
  txHash    String?
  status    String    @default("PENDING")
  videoId   String?
  sessionId String?
  creatorId String
  createdAt DateTime  @default(now())
  paidAt    DateTime?
  creator   User      @relation(fields: [creatorId], references: [id], onDelete: Cascade)

  @@map("creator_earnings")
}

model WalletTransaction {
  id              String   @id @default(cuid())
  userId          String
  type            String   // "DEPOSIT", "STAKE", "REFUND", "WITHDRAWAL"
  amount          Decimal  @db.Decimal(18, 8)
  balanceBefore   Decimal  @db.Decimal(18, 8)
  balanceAfter    Decimal  @db.Decimal(18, 8)
  description     String?
  x402PaymentId   String?  // For deposits via x402
  videoId         String?  // For stakes/refunds related to videos
  sessionId       String?  // For tracking view sessions
  createdAt       DateTime @default(now())
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("wallet_transactions")
}

model VideoLike {
  id        String   @id @default(cuid())
  userId    String
  videoId   String
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  video     Video    @relation(fields: [videoId], references: [id], onDelete: Cascade)

  @@unique([userId, videoId])
  @@map("video_likes")
}

model Subscription {
  id          String   @id @default(cuid())
  subscriberId String
  creatorId   String
  createdAt   DateTime @default(now())
  subscriber  User     @relation("UserSubscriptions", fields: [subscriberId], references: [id], onDelete: Cascade)
  creator     User     @relation("CreatorSubscribers", fields: [creatorId], references: [id], onDelete: Cascade)

  @@unique([subscriberId, creatorId])
  @@map("subscriptions")
}

model Settlement {
  id              String   @id @default(cuid())
  creatorId       String
  amount          Decimal  @db.Decimal(18, 8)
  status          String   @default("PENDING") // PENDING, PROCESSING, COMPLETED, FAILED
  txHash          String?  // Blockchain transaction hash
  errorMessage    String?  // If failed
  requestedAt     DateTime @default(now())
  processedAt     DateTime?
  completedAt     DateTime?
  creator         User     @relation(fields: [creatorId], references: [id], onDelete: Cascade)

  @@map("settlements")
}
